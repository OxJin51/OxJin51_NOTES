# 算法笔记：斐波那契数列的 4 种解法

## 数学定义

斐波那契数列定义如下：

$$
\ F_0 = 0, \quad F_1 = 1 \
\newline
\ F_n = F_{n-1} + F_{n-2} \quad (n \ge 2) \
$$


-----

## 方案 1：递推 / 动态规划 (Iterative / DP)

**【最常用、标准解法】**
这是解决一般性问题（N ≤ 90 且不需要高精度）的标准方案。

* **核心思想**：自底向上计算，避免递归的重复计算。
* **空间优化**：只需要记录前两个状态（滚轮法），不需要开数组。
* **复杂度**：时间 O(n)，空间 O(1)。
* **适用范围**：n ≤ 92 (long long 范围)。

```cpp
// 模板：标准递推 (滚轮优化版)
long long fib(int n) {
    if (n < 2) return n;
    
    long long a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b; // 滚轮向前滚动
        b = c;
    }
    return c;
}
```

-----

## 方案 2：高精度加法 (High Precision)

**【针对 P1255 数楼梯这类题目】**
当 N 很大（如 5000），结果会超过 1000 位，必须使用大整数模拟。

* **核心思想**：利用 `vector` 或数组模拟竖式加法。
* **复杂度**：时间 O(n × 位数)。
* **适用范围**：n 较大导致结果溢出 `long long`。

```cpp
// 模板：高精度 Fib
#include <vector>
#include <iostream>
using namespace std;

// 高精度加法 C = A + B
vector<int> add(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || i < B.size(); i++) {
        if (i < A.size()) t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}

void solveHighPrecFib(int n) {
    if(n == 0) { cout << 0; return; }
    vector<int> a = {0}; // F(0)
    vector<int> b = {1}; // F(1)
    
    for (int i = 2; i <= n; i++) {
        vector<int> c = add(a, b);
        a = b;
        b = c;
    }
    
    // 倒序输出
    for (int i = b.size() - 1; i >= 0; i--) cout << b[i];
}
```

-----

## 方案 3：矩阵快速幂 (Matrix Exponentiation)

**【进阶、面试、竞赛常用】**
这是**分治法**在斐波那契数列中的最高级应用。利用 O(log n) 的时间复杂度求解第 N 项。

* **核心思想**：
  利用线性代数原理，构造状态转移矩阵。
  
  $$
  \
  \begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}^n \begin{pmatrix} F_1 \\ F_0 \end{pmatrix}
  \
  $$
  求 A^n 时，使用**二分幂（Binary Exponentiation）**思想，将复杂度从 O(n) 降为 O(log n)。
* **适用范围**：n 极大（如 10¹⁸），且结果通常要求对某个大质数取模（如 10⁹+7）。

```cpp
// 模板：矩阵快速幂求解 Fib (模 1e9+7)
#include <iostream>
#include <cstring>
using namespace std;

const int MOD = 1e9 + 7;

struct Matrix {
    long long m[2][2];
    Matrix() { memset(m, 0, sizeof(m)); }
};

// 矩阵乘法
Matrix multiply(Matrix a, Matrix b) {
    Matrix c;
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            for (int k = 0; k < 2; k++)
                c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % MOD;
    return c;
}

// 矩阵快速幂 (分治思想核心)
Matrix power(Matrix a, long long n) {
    Matrix res;
    res.m[0][0] = 1; res.m[1][1] = 1; // 单位矩阵
    while (n > 0) {
        if (n & 1) res = multiply(res, a); // 如果n是奇数，乘上底数
        a = multiply(a, a); // 底数自乘（翻倍）
        n >>= 1; // 指数除以2
    }
    return res;
}

long long fibFast(long long n) {
    if (n == 0) return 0;
    Matrix base;
    base.m[0][0] = 1; base.m[0][1] = 1;
    base.m[1][0] = 1; base.m[1][1] = 0;
    
    // 计算 base^(n-1)
    Matrix res = power(base, n - 1);
    
    // 结果是 res[0][0] * F(1) + res[0][1] * F(0)
    // 因为 F(1)=1, F(0)=0，所以直接返回 res.m[0][0]
    return res.m[0][0];
}
```

-----

## 方案 4：通项公式 (General Formula)

**【仅限理论推导】**
利用特征方程求出的通项公式（Binet Formula）：
$$
[ F_n = \frac{1}{\sqrt{5}} \left[ \left(\frac{1+\sqrt{5}}{2}\right)^n - \left(\frac{1-\sqrt{5}}{2}\right)^n \right] ]
$$


* **缺点**：计算机浮点数（double）有精度误差。当 n 稍大时，结果就不准了。
* **用途**：主要用于数学证明或估算位数，编程解题中**极少直接使用**。

-----

## 总结对比表

| 方案           | 核心思想        | 时间复杂度   | 空间复杂度 | 适用场景                   |
| :------------- | :-------------- | :----------- | :--------- | :------------------------- |
| **暴力递归**   | 定义直接翻译    | O(2ⁿ) (爆炸) | O(n)       | 教学演示，实际**不可用**   |
| **递推 / DP**  | 滚轮变量        | O(n)         | O(1)       | N ≤ 90，常规工程           |
| **高精度**     | 数组模拟加法    | O(n × len)   | O(len)     | 结果溢出，如 **P1255**     |
| **矩阵快速幂** | 分治 + 线性代数 | O(log n)     | O(1)       | N 极大 (如 10¹⁸)，结果取模 |

**建议：**

1. 如果是 P1255 这种题，背熟**方案 2**（高精度模板）。
2. 如果是普通的算法面试或工程问题，熟练手写**方案 1**。
3. 如果遇到 N 很大的 Mod 题，必须上**方案 3**。

---

这份笔记已经移除了所有可能导致Typora渲染问题的数学公式符号，改用LaTeX块级公式和普通文本表示，同时保留了所有原始内容。