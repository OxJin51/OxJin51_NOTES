# 算法笔记：贪心算法 (Greedy Algorithm)

贪心算法的核心哲学是：**目光短浅，活在当下。**

### 什么是“贪心策略”？

就是在解决问题的每一步中，都采取**当前状态下最好（最优）的选择**，并希望这些“局部最优”累加起来，能自动导向“全局最优”。

### 如何判断一道题能否用贪心？

必须同时满足两个直觉：

1. **无后效性（No Regret）**：我现在的选择，不会让后面的路变得更难走，或者说现在的选择不依赖于还没发生的未来。
2. **局部即全局**：如果我在每一步都拿最多的，最后总和一定是最大的。

### 三步检验法（必要条件）

做题前，心里默念这三步：

1. **分解**：能不能把大问题拆成一步步的小选择？
2. **择优**：每一步有没有一个明显的“最划算”标准？
3. **验证**：如果我选了这个“最划算”的，会不会导致后面错过一个“惊天大礼包”？（如果**不会**，那就是贪心）。



### 《P2356 弹珠游戏》

----

## 题目描述

MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏——超级弹珠。

游戏的内容是：在一个 
$$
n \times n
$$
的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方。

## 输入格式

输入有两行，第一行一个正整数 n，接下来 n 行，每行 n 列，如果有敌人则为一个正整数，否则为 0。

## 输出格式

输出共一行，最多分数，如果连你的容身之地都没有，请输出“Bad Game!”

## 输入输出样例 #1

### 输入 #1

```
4
1 1 1 0
1 1 1 1
1 1 1 1
0 1 1 1
```

### 输出 #1

```
6
```

## 说明/提示

【数据范围】

$$
对于 30\% 的数据，1\leq n\leq 10；
$$

$$
对于 100\% 的数据，1\leq n\leq 1000，
$$

保证容身之地的数量小于 10000，保证每个位置敌人的数量不超过 1000。

---

贪心算法中最直观的一种：**枚举即贪心**。

### 为什么不需要 `vis` 数组判重？

你的担忧很有道理：一般来说，如果是十字交叉形状，中心点（交叉点）会被横着算一次，竖着算一次，确实重复了。

**但在本题中，这个重复是“无害”的。**

- **题目铁律**：你只能把弹珠放在 **空地（数值为 0）** 的位置。

$$
总分 = RowSum[i] + ColSum[j] - 0
$$

#### 步骤一：预处理（这是关键！）

与其每次临时抱佛脚去数数，不如一开始就把每一行、每一列的总分算好，存进“账本”。

我们需要两个辅助数组：

- `h[i]`：表示第 i 行的敌人总分数。
- `l[j]`：表示第 j 列的敌人总分数。

在读入数据的时候，就可以顺手把这两个数组填满。



### 列数组 `l[]` 怎么处理？

你问“难道是再加一个循环？” —— 答案是：**完全不需要！**

想象一下你去超市购物。当你拿起一件商品（读入 `arr[i][j]`）时，这件商品既属于“你的购物车”（第 i 行），也属于“超市的商品架”（第 j 列）。

**我们可以在读入的同时，顺手把这一列的账也记上。**

- **当前做法：** `sum_h += arr[i][j];` （只记了行的账）
- **改进做法：** 既然你知道当前读入的数属于第 $j$ 列，直接把它的值加到 `l[j]` 里去就行了！

```cpp
cin >> arr[i][j];
h[i] += arr[i][j]; // 记入行账本（注意这里不用中间变量 sum_h 也行，直接加到数组里）
l[j] += arr[i][j]; // 同时记入列账本！
```

这样读完 N x N 的数据，`h` 和 `l` 两个数组就都准备好了。

#### 步骤二：贪心决策

只要有了上面两个“账本”，我们的决策就变得极度简单：

1. 把棋盘上的每个格子扫描一遍。
2. 如果是敌人（非 0），跳过。
3. 如果是空地（0），它的得分直接查账本：`current_score = h[i] + l[j]`。
4. **贪心时刻**：如果 `current_score` 比我看过的所有得分都高，我就更新我的最高分记录 `ans`。







































---

模板：

### 匹配博弈类（Ref：田忌赛马、独木舟）

- **通用策略**：双方排序（通常是升序或降序）。
- **适用条件**：两个集合元素两两配对，追求某种总和最大/最小。
- **常犯错误**：只盯着最大的看，忘了处理相同时的情况。
- **一句话口诀**：**两军对垒先排序，首尾指针找牺牲。**

### 2. 区间调度类（Ref：活动选择、线段覆盖）

- **通用策略**：
  1. 按照**右端点（结束时间）** 从小到大排序。
  2. 选第一个结束的，然后把所有和它时间冲突的删掉。
  3. 重复。
- **适用条件**：很多时间段，问最多能参加几个活动。
- **常犯错误**：按开始时间排序（大错特错！）。
- **一句话口诀**：**想做多事看结束，谁先完事谁先录。**

### 3. 局部最优类（Ref：合并果子、Huffman树）

- **通用策略**：使用**优先队列 (Priority Queue)**。
  1. 把所有元素扔进小根堆。
  2. 每次拿出最小的两个合并，代价加回去。
- **适用条件**：哈夫曼编码类型，越早合并的数被加的次数越多。
- **常犯错误**：手动排序数组（效率低，插入新值很麻烦）。
- **一句话口诀**：**聚沙成塔用堆排，最小两个合起来。**