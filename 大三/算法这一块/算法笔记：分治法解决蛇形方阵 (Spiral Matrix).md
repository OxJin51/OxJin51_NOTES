# 算法笔记：分治法解决蛇形方阵 (Spiral Matrix)

## 1. 基础知识：计算机二维坐标系标准

在数学几何中，x轴通常指水平方向，y轴指垂直方向。但在计算机矩阵（二维数组）中，定义通常是**相反**的，极易混淆。

### 标准定义（Row-Major）

- **行 (Row)**：对应垂直方向，**向下递增**。通常用变量 i, r, x表示。
- **列 (Column)**：对应水平方向，**向右递增**。通常用变量 j, c, y 表示。
- **原点 (0,0)**：位于矩阵的**左上角**。

### 坐标可视化图解

```text
       y (列号 Col) —> 向右增加
       0   1   2   3
     ___________________
  0 | (0,0) (0,1) (0,2) (0,3)
x 1 | (1,0) (1,1) (1,2) (1,3)
  2 | (2,0) (2,1) (2,2) (2,3)
  | | (3,0) (3,1) (3,2) (3,3)
  v
 (行号 Row) —> 向下增加
```

> **记忆口诀**：先下后右（先定第几层，再定第几个）。代码中写作 `arr[x][y]` 或 `arr[row][col]`。

-----

## 2. 算法核心：减治法 (Decrease and Conquer)

- **分解**：将N*N的矩阵看作由 **"最外层边框"** 包裹着 **"内部子矩阵"** 组成。
- **递归逻辑**：
  1. 填满当前最外层的四条边。
  2. 剥去这一层，进入内部 $(N-2) \times (N-2)$ 的子矩阵继续填充。
  3. **Base Case**：当边长 $size \le 0$ 时停止；若 $size=1$（奇数 $N$ 的中心点），直接填入并结束。
- **通用原则**：**左闭右开 (Left-Closed, Right-Open)**。
  每条边长度为 `size`，但为了避免四个角被重复填充，每条边只填 `size-1` 个格子。

-----

## 3. 实现方案 A：模拟游走法 (推荐，老师的方法)

**特点**：思维负担小，像控制机器人一样移动。
**核心**：利用变量 `i` (行) 和 `j` (列) 的残留值，填完一条边后，坐标刚好停在下一条边的起点，实现"无缝接力"。

```cpp
// 模拟法：利用 i++ 和 j++ 控制方向
// begin: 起点偏移量 (如第0圈为0，第1圈为1)
// size: 当前圈的边长
void fill_simulate(int number, int begin, int size) {
    if (size == 0) return;
    if (size == 1) {
        data[begin][begin] = number;
        return;
    }

    int i = begin;
    int j = begin;
    int k;

    // 1. 上方边 (向右走 j++)
    for (k = 0; k < size - 1; k++) {
        data[i][j] = number++;
        j++; 
    }
    // 此时 i不变, j停在最右列

    // 2. 右侧边 (向下走 i++)
    for (k = 0; k < size - 1; k++) {
        data[i][j] = number++;
        i++; 
    }
    // 此时 j不变, i停在最下行

    // 3. 下方边 (向左走 j--)
    for (k = 0; k < size - 1; k++) {
        data[i][j] = number++;
        j--; 
    }
    // 此时 i不变, j停在最左列

    // 4. 左侧边 (向上走 i--)
    for (k = 0; k < size - 1; k++) {
        data[i][j] = number++;
        i--; 
    }
    // 此时回到起点 (begin, begin) 的正下方 (begin+1, begin)，但无需关心，
    // 因为下一层递归会直接重置起点。

    // 递归进入内圈：起点缩进1，边长减2
    fill_simulate(number, begin + 1, size - 2);
}
```

-----

## 4. 实现方案 B：数学计算法 (公式推导)

**特点**：不依赖游走状态，通过**相对坐标公式**直接计算目标位置。逻辑更"函数式"，适合并行计算或随机访问，但推导容易出错。
**核心**：基准点 + 偏移量 $k$。

```cpp
// 计算法：通过公式直接算出 arr[x][y]
// x, y: 当前圈左上角的绝对坐标
// size: 当前圈的边长
void fill_calculate(int x, int y, int size, int &number) {
    if (size == 0) return;
    if (size == 1) {
        data[x][y] = number++;
        return;
    }

    // k 代表当前边走的步数 (0 到 size-2)
    
    // 1. 上方边：行不变(x)，列增加(y+k)
    for (int k = 0; k < size - 1; k++) 
        data[x][y + k] = number++;

    // 2. 右侧边：行增加(x+k)，列固定最右(y+size-1)
    for (int k = 0; k < size - 1; k++) 
        data[x + k][y + size - 1] = number++;

    // 3. 下方边：行固定最下(x+size-1)，列减小(减去偏移量 k)
    // 注意：起点是右下角，向左走
    for (int k = 0; k < size - 1; k++) 
        data[x + size - 1][y + size - 1 - k] = number++;

    // 4. 左侧边：列固定最左(y)，行减小(减去偏移量 k)
    // 注意：起点是左下角，向上走
    for (int k = 0; k < size - 1; k++) 
        data[x + size - 1 - k][y] = number++;

    // 递归：坐标均+1，边长-2
    fill_calculate(x + 1, y + 1, size - 2, number);
}
```

-----

## 5. 总结对比

| 特性           | 方案 A：模拟游走 (Simulation) | 方案 B：数学计算 (Calculation) |
| :------------- | :---------------------------- | :----------------------------- |
| **思维难度**   | **低** (推荐)                 | 中 (容易搞错下标方向)          |
| **代码直观性** | 直观，像贪吃蛇移动            | 需要脑补几何坐标               |
| **核心操作**   | `j++`, `i++`, `j--`, `i--`    | `y+k`, `x+k`, `y+size-1-k`...  |
| **易错点**     | 忘记 `size-1` 导致覆盖拐角    | 下标 `-k` 还是 `+k` 容易算反   |
| **适用场景**   | 螺旋矩阵、回形针遍历          | 需要直接求第 N 个数的坐标时    |