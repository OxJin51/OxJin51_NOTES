# 算法笔记：DFS 与回溯法 (Backtracking)

## 一、 核心思维模型

DFS（深度优先搜索）解决的是 **“在一个树形空间中寻找合法路径”** 的问题。为了理清逻辑，建议始终坚持 **“盒子与卡片”** 的物理模型：

在盒子里面放卡片。

- **`u` (或 `step`)**：代表 **“当前走到了第几层（第几个盒子）”**。
  - 决定递归的**深度**。
  - 用于判断是否到达终点（边界条件）。
- **`i` (或 `val`)**：代表 **“当前尝试放入的元素（手中的卡片）”**。
  - 决定每一层的**广度**。
  - 需要在循环中枚举。



### 通用代码框架



C++

```cpp
void dfs(int u, [额外参数]) {
    // 1. 边界/截止条件 (End Condition)
    if (u > target_depth) {
        记录结果(); // for() cout<< ;
        return; // 返回
    }

    // 2. 枚举选择列表 (Selection List)
    // 根据是排列还是组合，i 的起点和范围不同
    for (int i = start_val; i <= n; i++) {
        
        // 3. 剪枝与合法性判断 (Pruning/Check)
        if (check(i)) {
            
            // 4. 做选择 (Make Choice)
            path[u] = i;      // 放入路径
            st[i] = true;     // 标记占用 (仅排列需要)
            
            // 5. 进入下一层 (Recurse)
            dfs(u + 1, [更新额外参数]);
            
            // 6. 撤销选择 (Backtrack/Restore)
            st[i] = false;    // 恢复现场 (仅排列需要)
            // path[u] = 0;   // 可选，逻辑上清空
        }
    }
}
```

------



## 二、 三大经典模型解析



根据**顺序是否重要**以及**是否允许重复**，DFS 主要分为排列模型和组合模型。



### 1. 全排列模型 (Permutation)



- **典型题目**：P1008 三连击、全排列生成。
- **特点**：顺序重要 ($[1,2] \neq [2,1]$)。
- **核心逻辑**：
  - 每次枚举都从头开始 (`1` 到 `n`)。
  - **必须**使用 `st[]` 数组记录哪些数字已被使用，防止重复选择。

```cpp
// 核心片段
for (int i = 1; i <= n; i++) { // 每次都从 1 搜到 n
    if (!st[i]) {              // 关键：检查是否用过
        st[i] = true;          // 标记
        nums[u] = i;
        dfs(u + 1);
        st[i] = false;         // 回溯
    }
}
```



### 2. 组合输出模型 (Combination)



- **典型题目**：P1157 组合的输出。
- **特点**：顺序不重要 ($[1,2] == [2,1]$)，通常要求按升序输出。
- **核心逻辑**：
  - 引入 `start` 参数。
  - 下一层搜索只能从 **当前数字的下一个** 开始，绝不回头。
  - **不需要** `st[]` 数组（因为 `start` 限制了不会选到之前的数）。

C++

```
// u: 选了几个数, start: 从哪个数开始选
void dfs(int u, int start) {
    // ... 边界判断 ...
    
    // 关键：i 从 start 开始，而不是从 1 开始
    for (int i = start; i <= n; i++) {
        nums[u] = i;
        dfs(u + 1, i + 1); // 下一层从 i+1 开始
        // 组合问题通常不需要显式 st[i]=false，因为 i 是单调递增的
    }
}
```



### 3. 选数/子集和模型 (Subset Sum)



- **典型题目**：P1036 选数（判断素数）。
- **特点**：组合问题的变种。不需要输出路径，只需要计算结果（如：和、个数）。
- **核心逻辑**：
  - 基于组合模型（使用 `start` 参数）。
  - 在递归参数中维护**状态值**（如 `currentSum`），省去全局数组求和的开销。

C++

```
// currentSum: 当前累加的和
void dfs(int u, int start, int currentSum) {
    if (u > k) { // 选够了 k 个数
        if (isPrime(currentSum)) res++;
        return;
    }
    
    for (int i = start; i <= n; i++) {
        // 直接在参数中累加，隐式地“做选择”和“回溯”
        dfs(u + 1, i + 1, currentSum + nums[i]); 
    }
}
```

------



## 三、 总结与对比表 (Cheat Sheet)



| **维度**     | **全排列 (Permutation)**  | **组合/选数 (Combination)** |
| ------------ | ------------------------- | --------------------------- |
| **关注点**   | 顺序重要 ($1,2 \neq 2,1$) | 元素集合 ($1,2 = 2,1$)      |
| **循环范围** | `1` 到 `n`                | `start` 到 `n`              |
| **去重方式** | `st[]` (bool 数组)        | `start` 参数 (人为规定升序) |
| **递归参数** | `dfs(u)`                  | `dfs(u, start)`             |
| **回溯操作** | 必须显式 `st[i] = false`  | 通常不需要显式操作          |
| **典型例题** | 洛谷 P1706, P1008         | 洛谷 P1157, P1036           |

------



## 四、 易错点自检 (Self-Check)



在写代码时，请对照以下几点进行“肌肉记忆”检查：

1. **Return 陷阱**：
   - 在 `if (u > n)` 的边界判断块里，输出完结果后，**一定要加 `return;`**。否则程序会越界继续执行，导致崩溃或死循环。
2. **下标对齐**：
   - 如果是 `dfs(1)` 开始，数组通常用 `1~n`。
   - 如果是 `dfs(0)` 开始，数组通常用 `0~n-1`。
   - **建议**：如果不涉及数学性质（如乘法），尽量用 0-based（从0开始），与 C++ 数组习惯保持一致。
3. **恢复现场**：
   - 在排列问题中，`st[i] = true` 必须对应一个 `st[i] = false`。
   - 这个操作必须在 `dfs(u+1)` 之后执行。
4. **变量名混淆**：
   - 时刻分清 `u` (深度/盒子) 和 `i` (数值/卡片)。如果不熟练，建议将变量名改为 `step` 和 `val`。

------

DFS剪枝问题

概念：

一旦发现前面的路**绝对不是最优解**或者**根本走不通**，就立刻停止，不再继续浪费时间往下搜。

1. ### 最优性剪枝（Optimality Pruning）

想象你在玩一个寻宝游戏，目的是用**最少的步数**找到宝藏。

- **场景**：假设你刚才已经运气很好，发现了一条路线，只要 **10 步** 就能走到终点。
- **现状**：现在你正在尝试另一条新路线，而且你已经走了 **11 步**，但还没看到终点的影子。
- **剪枝判断**：既然你要找的是“最少步数”，而现在的步数（11步）已经超过了之前记录的最佳答案（10步），那么这条路就算最后能通向终点，也绝对不可能是冠军了。
- **操作**：直接放弃（`return`），不再继续往下走。

### 2. 记忆化剪枝 / 冗余剪枝（Redundancy Pruning）

这个技巧是为了防止“做无用功”。

- **场景**：假设你正在大楼里探索。你之前已经发现，从起点按 **2 次** 按钮就能到达 **5 楼**。
- **现状**：现在你通过一条绕来绕去的复杂路线，按了 **8 次** 按钮，又来到了 **5 楼**。
- **剪枝判断**：既然同一个楼层，你之前 2 步就能到，现在的 8 步显然更差。任何从这里开始的后续操作，肯定都不如之前的方案好。
- **操作**：直接放弃，这条分支没必要再搜了。

------

通过这两个剪枝，原本指数级爆炸的搜索树🌳就会被修剪得非常稀疏，程序运行速度会快几百倍甚至几万倍。



初始化min_steps

for(int i=1;i<=n;i++)

memset(数组名,填充物,sizeof(数组名));

memset(min_steps,INT_MAN,);



dfs的开头应该为剪枝和递归条件终止退出

