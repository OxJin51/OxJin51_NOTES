#  C++ 高精度算法详解 (High-Precision Arithmetic)

## 0. 核心综述

### 为什么要用高精度？

C++ 原生最大的整数类型 `unsigned long long`约为 1.8×10¹⁸。一旦计算结果超过这个范围（如 100 的阶乘、大数乘积），计算机就会"爆掉"（溢出）。

**高精度算法的本质**：用**数组**（`vector<int>`）模拟人类在纸上做竖式运算的过程。

### 核心地基：倒序存储 (Little-Endian)

这是所有代码能够运行的前提。

- **人类习惯**：高位在左，低位在右（如 123）。
- **计算机习惯**：**低位在前，高位在后**（如 `{3, 2, 1}`）。 `A[0]`是个位 `A[1]`是十位 ...
- **为什么？** 运算中产生的"进位"是往高位跑的。在数组**末尾**追加元素（`push_back`）是 O(1)的操作，而在数组**开头**插入元素是 O(N)的，所以倒着存效率最高。

------

## 1. 高精度加法 (A+B)

### 🧠 原理：接力跑

想象这是一场接力赛，每一位算完，把"接力棒"（进位 t）传给下一位。

1. **对齐**：因为倒序存储，下标 `0`天然对齐了个位。
2. **计算**：`当前位和 = A[i] + B[i] + t`。
3. **拆分**： 留下的：`和 % 10` 传走的：`和 / 10`

### 📝 代码模板

```
// C = A + B
vector<int> add(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0; // 进位
    // 只要 A 没跑完，或者 B 没跑完，或者还有进位没处理，就继续
    for (int i = 0; i < A.size() || i < B.size() || t; i++) {
        if (i < A.size()) t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10); // 留个位
        t /= 10;             // 进位
    }
    return C;
}
```

------

## 2. 高精度减法 (A−B)

### 🧠 原理：借位法则

**前提**：默认大数减小数（A≥B）。如果 A<B，则算 −(B−A)。

1. **计算**：`差 = A[i] - B[i] - t`（t是上一轮被借走的）。
2. **判断**： 如果 `差 ≥ 0`：够减，`t = 0`。 如果 `差 < 0`：不够减！向高位借 1 当 10。当前位结果变为 `差 + 10`，标记 `t = 1`。
3. **修剪**：算 100 - 99 会得到 `{1, 0, 0}`（即 001），必须把末尾多余的 0 去掉。

### 📝 代码模板

```
// 辅助：比较 A 和 B 大小
bool cmp(vector<int> &A, vector<int> &B) {
    if (A.size() != B.size()) return A.size() > B.size();
    for (int i = A.size() - 1; i >= 0; i--)
        if (A[i] != B[i]) return A[i] > B[i];
    return true;
}

// C = A - B (需保证 A >= B)
vector<int> sub(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0; // 借位
    for (int i = 0; i < A.size(); i++) {
        t = A[i] - t; // 减去之前的借位
        if (i < B.size()) t -= B[i]; // 减去 B 的当前位
        
        // (t + 10) % 10：无论 t 是正数还是负数，都能得到正确的个位
        C.push_back((t + 10) % 10);
        
        if (t < 0) t = 1; // 需要借位
        else t = 0;
    }
    // ⚠️ 去除前导零（保留至少一位，如结果是0）
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

------

## 3. 高精度乘法 (A×B)

乘法分两种情况，原理略有不同。

### 情况 A：高精 × 低精 (BigInt × int)

*这就是你解决"质数乘积"题目时用的算法。*

- **原理**：把大数 A的每一位都乘以整数 b，产生巨大的进位，再慢慢拆解进位。

```
vector<int> mul_short(vector<int> &A, int b) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i++) {
        if (i < A.size()) t += A[i] * b; // 加上当前位乘积
        C.push_back(t % 10); // 留个位
        t /= 10;             // 进位
    }
    // 去前导零 (当 b=0 时)
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 情况 B：高精 × 高精 (BigInt × BigInt)

- **原理**：卷积（握手模型）。 A的第 i位（代表 10i）和 B的第 j位（代表 10j）相乘，结果贡献给 C的第 i+j位（代表 10i+j）。
- **公式**：C[i+j]+=A[i]×B[j]

```
vector<int> mul(vector<int> &A, vector<int> &B) {
    // 结果位数最多是 A.size + B.size
    vector<int> C(A.size() + B.size(), 0); 

    for (int i = 0; i < A.size(); i++) {
        for (int j = 0; j < B.size(); j++) {
            C[i + j] += A[i] * B[j];
            C[i + j + 1] += C[i + j] / 10; // 进位加到下一位
            C[i + j] %= 10;               // 当前位只留个位
        }
    }
    // 去前导零
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

------

## 4. 高精度除法 (A÷b)

### 🧠 原理：分糖果

**这是唯一一个从高位开始算的运算！**

想象把一堆糖果分给 b个人：

1. 从最高位（数组末尾）开始拿糖果。
2. **余数传递**：分不完的糖果（余数 r）不能扔，要乘 10 加到下一位去继续分。
3. **公式**：r=r×10+A[i]
4. **反转**：因为是从高位算出的商，存进去是正序的，最后要 `reverse`回倒序。

### 📝 代码模板 (BigInt / int)

```
// C = A / b, r 是引用传递的余数
vector<int> div(vector<int> &A, int b, int &r) {
    vector<int> C;
    r = 0;
    // ⚠️ 关键：从高位（数组末尾）开始遍历
    for (int i = A.size() - 1; i >= 0; i--) {
        r = r * 10 + A[i];  // 上一位余数补到这一位
        C.push_back(r / b); // 记录商
        r %= b;             // 更新余数
    }
    // ⚠️ 关键：反转回倒序存储
    reverse(C.begin(), C.end());
    // 去前导零
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

------

## ⚡️ 避坑检查清单 (Checklist)

在考场上写完代码后，请按此表自查：

1. **存储方向对了吗？** 必须是倒序（个位在 `res[0]`）。
2. **前导零去掉了吗？** 减法、乘法、除法都可能产生前导零，`while`循环去零不能少。
3. **循环边界对了吗？** 加减乘：`i < A.size()` 除法：`i = A.size() - 1; i ≥ 0`
4. **变量初始化了吗？** 乘积初始值要是 1 (`push_back(1)`). 进位/借位初始值要是 0.
5. **作用域搞错了吗？** 别在 `for`循环里重新定义 `int t`，会覆盖外部变量。
6. **引用传参了吗？** 函数参数加 `&`（如 `vector<int> &A`）可以避免数组复制，大幅提升速度。