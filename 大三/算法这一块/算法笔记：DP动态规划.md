# 算法笔记：DP动态规划

动态规划（Dynamic Programming，简称 **DP**）

DP 不是什么黑魔法，它本质上就是**“带记事本的递归”**或者**“填表格”**

**DP 的核心思想只有两点：**

1. **大事化小（最优子结构）：** 求第 10 级（大问题）依赖于第 9 级和第 8 级（小问题）。
2. **不走回头路（无后效性）：** 一旦你算出了走到第 8 级有 X 种方法，你就把它**记下来**。以后不管谁问你需要用到“第 8 级”的数据，你直接查记录，绝对不要重新算一遍



我已经根据您的优化要求，对这份笔记内容进行了全面优化。以下是优化后的版本，确保在Typora中能够完美渲染：

------

# 0-1背包问题与动态规划模板总结

## 🎒 1. 采药问题（0-1背包）对话总结

**核心问题：**

在有限的时间 T内，面对 M株草药，每株草药有特定的采摘时间 t[i]和价值 v[i]，如何选择才能让总价值最大？

**核心逻辑：**

对于每一株草药，你只有两个选择（这就是"0-1"的含义）：

1. **不采（0）：** 也就是"舍弃"这株草药，继承前面的结果。
2. **采（1）：** 付出时间成本，获得价值，剩余的时间去前面的结果里找最优解。

------

## 📏 2. 核心 DP 模板

以后遇到类似的"有限容量求最大价值"的问题，直接套用这个模板思路。

### **版本一：二维数组（基础版，易理解）**

- **状态定义：** dp[i][j]表示在前 i个物品中做选择，且当前背包容量（时间）为 j时，能获得的最大价值。

- 

  **状态转移方程：**
  $$
  dp[i][j]=max(dp[i−1][j],dp[i−1][j−t[i]]+v[i])
  $$

  - dp[i−1][j]：**不采**第 i株。容量不变，价值等于前 i−1株的结果。
  - dp[i−1][j−t[i]]+v[i]：**采**第 i株。前提是时间够用 (j≥t[i])。我们要腾出 t[i]的空间，去前 i−1株的状态里找 dp[i−1][j−t[i]]，然后加上当前的价值 v[i]。

### **版本二：一维数组（进阶版，空间优化）**

这是做题时最常用的写法，通过"滚动数组"把 i这一维省去了。

- **状态定义：** dp[j]表示容量为 j时能获得的最大价值。

- 

  **状态转移方程：**

  ```
  dp[j]=max(dp[j],dp[j−t[i]]+v[i])
  ```

------

## ⚠️ 3. 重难点与易错点回顾

根据我们之前的交流，以下是你最需要警惕的地方：

### **🔴 难点 1：状态压缩后的遍历顺序（最易错！）**

在把二维改成一维时，内层循环（遍历时间/容量 j）**必须是倒序的**（从大到小）。

- **为什么？** dp[j]的更新需要用到上一轮（i−1）的数据。 如果你**从左往右（从小到大）** 更新：你在计算 dp[j]时，用到的 dp[j−t[i]]已经是这一轮（第 i轮）刚更新过的值了。这意味着你可能把同一株草药采了多次（变成了"完全背包问题"）。 如果你**从右往左（从大到小）** 更新：你在计算 dp[j]时，用到的 dp[j−t[i]]还在更小的索引位置，它还没被更新，仍然是上一轮（i−1）的旧值。这正是我们想要的。

- 

  **代码逻辑（伪代码）：**

  ```
  for i 从 1 到 M (物品):
      for j 从 T 到 t[i] (容量，必须倒序!):
          dp[j] = max(dp[j], dp[j - t[i]] + v[i])
  ```

### **🟠 难点 2：初始化的意义**

- 通常将 dp数组全部初始化为 **0**。这代表"如果没有任何时间或不采任何草药，价值为 0"。
- 如果你遇到题目要求"**必须恰好装满**背包"，初始化会有所不同（通常设为负无穷，只有 dp[0]=0）。但在采药问题中，不要求装满，初始化为 0 即可。

### **🟡 难点 3：理解"不选"与"选"的权衡**

就像我们刚才讨论最长公共子序列（LCS）时一样，dp的本质就是在"各种可能性"中取最大值（max）。

- LCS 问题里的"舍弃字符"是为了去前面找匹配。
- 背包问题里的"舍弃物品"是为了保留容量给性价比更高的物品。

------

## 📋 4. 下一步学习建议

通过这个总结，你对 0-1 背包问题的逻辑清晰了吗？如果没问题，我们可以回到 **最长公共子序列 (LCS)** 的状态转移方程，继续推导最后的代码实现。你是想先看 LCS 的代码结构，还是手动模拟一遍 LCS 的填表过程来加深理解？
