# 算法笔记：DP动态规划

动态规划（Dynamic Programming，简称 **DP**）

DP 不是什么黑魔法，它本质上就是**“带记事本的递归”**或者**“填表格”**

**DP 的核心思想只有两点：**

1. **大事化小（最优子结构）：** 求第 10 级（大问题）依赖于第 9 级和第 8 级（小问题）。
2. **不走回头路（无后效性）：** 一旦你算出了走到第 8 级有 X 种方法，你就把它**记下来**。以后不管谁问你需要用到“第 8 级”的数据，你直接查记录，绝对不要重新算一遍



我已经根据您的优化要求，对这份笔记内容进行了全面优化。以下是优化后的版本，确保在Typora中能够完美渲染：

------

# 0-1背包问题与动态规划模板总结

## 🎒 1. 采药问题（0-1背包）对话总结

**核心问题：**

在有限的时间 T内，面对 M株草药，每株草药有特定的采摘时间 t[i]和价值 v[i]，如何选择才能让总价值最大？

**核心逻辑：**

对于每一株草药，你只有两个选择（这就是"0-1"的含义）：

1. **不采（0）：** 也就是"舍弃"这株草药，继承前面的结果。
2. **采（1）：** 付出时间成本，获得价值，剩余的时间去前面的结果里找最优解。

------

## 📏 2. 核心 DP 模板

以后遇到类似的"有限容量求最大价值"的问题，直接套用这个模板思路。

### **版本一：二维数组（基础版，易理解）**

- **状态定义：** dp[i][j]表示在前 i个物品中做选择，且当前背包容量（时间）为 j时，能获得的最大价值。

- 

  **状态转移方程：**
  $$
  dp[i][j]=max(dp[i−1][j],dp[i−1][j−t[i]]+v[i])
  $$

  - dp[i−1][j]：**不采**第 i株。容量不变，价值等于前 i−1株的结果。
  - dp[i−1][j−t[i]]+v[i]：**采**第 i株。前提是时间够用 (j≥t[i])。我们要腾出 t[i]的空间，去前 i−1株的状态里找 dp[i−1][j−t[i]]，然后加上当前的价值 v[i]。

### **版本二：一维数组（进阶版，空间优化）**

这是做题时最常用的写法，通过"滚动数组"把 i这一维省去了。

- **状态定义：** dp[j]表示容量为 j时能获得的最大价值。

- 

  **状态转移方程：**

  ```
  dp[j]=max(dp[j],dp[j−t[i]]+v[i])
  ```

------

## ⚠️ 3. 重难点与易错点回顾

根据我们之前的交流，以下是你最需要警惕的地方：

### **🔴 难点 1：状态压缩后的遍历顺序（最易错！）**

在把二维改成一维时，内层循环（遍历时间/容量 j）**必须是倒序的**（从大到小）。

- **为什么？** dp[j]的更新需要用到上一轮（i−1）的数据。 如果你**从左往右（从小到大）** 更新：你在计算 dp[j]时，用到的 dp[j−t[i]]已经是这一轮（第 i轮）刚更新过的值了。这意味着你可能把同一株草药采了多次（变成了"完全背包问题"）。 如果你**从右往左（从大到小）** 更新：你在计算 dp[j]时，用到的 dp[j−t[i]]还在更小的索引位置，它还没被更新，仍然是上一轮（i−1）的旧值。这正是我们想要的。

- 

  **代码逻辑（伪代码）：**

  ```
  for i 从 1 到 M (物品):
      for j 从 T 到 t[i] (容量，必须倒序!):
          dp[j] = max(dp[j], dp[j - t[i]] + v[i])
  ```

### **🟠 难点 2：初始化的意义**

- 通常将 dp数组全部初始化为 **0**。这代表"如果没有任何时间或不采任何草药，价值为 0"。
- 如果你遇到题目要求"**必须恰好装满**背包"，初始化会有所不同（通常设为负无穷，只有 dp[0]=0）。但在采药问题中，不要求装满，初始化为 0 即可。

### **🟡 难点 3：理解"不选"与"选"的权衡**

就像我们刚才讨论最长公共子序列（LCS）时一样，dp的本质就是在"各种可能性"中取最大值（max）。

- LCS 问题里的"舍弃字符"是为了去前面找匹配。
- 背包问题里的"舍弃物品"是为了保留容量给性价比更高的物品。

------

## 📋 4. 下一步学习建议

通过这个总结，你对 0-1 背包问题的逻辑清晰了吗？如果没问题，我们可以回到 **最长公共子序列 (LCS)** 的状态转移方程，继续推导最后的代码实现。你是想先看 LCS 的代码结构，还是手动模拟一遍 LCS 的填表过程来加深理解？





### 📝 实验题 1：最长公共子序列 (LCS) —— 思路笔记

#### **0. 输入与目标**

- **输入**：两个序列（或字符串）
  - 序列 A（长度 n）：比如 `3 2 1 4 5`
  - 序列 B（长度 n）：比如 `1 2 3 4 5`
- **目标**：找到它们**最长**的公共子序列的**长度**。

------

#### **1. 状态定义：`dp[i][j]`**

- **i**：代表序列 A 处理到了第 i 个字符（前 i 个）。

- **j**：代表序列 B 处理到了第 j 个字符（前 j 个）。

- **`dp[i][j]` 的含义**：

  > 序列 A 的前 i 个字符 和 序列 B 的前 j 个字符，它们的最长公共子序列的长度。

  - *边界初始化*：dp[0][j] = 0, dp[i][0] = 0 （空序列没有公共部分）。

------

#### **2. 决策 & 状态转移方程 (核心)**

我们在填 dp[i][j] 这个格子时，只看 A 的第 i 个字符 (A[i]) 和 B 的第 j 个字符 (B[j])。

**情况 A：字符相等 (A[i] == B[j])**

- **逻辑**：既然一样，那这个字符肯定算在公共序列里！长度在之前的基上 +1。

- 方程：

  

  dp[i][j] = dp[i-1][j-1] + 1

  

  (注：找左上角的值加 1)

**情况 B：字符不相等 (A[i] \neq B[j])**

- **逻辑**：这两个字符不能配对。我们必须“继承”历史上最好的成绩。

  - 选择 1：舍弃 A 的当前字符，看 `dp[i-1][j]`
  - 选择 2：舍弃 B 的当前字符，看 `dp[i][j-1]`
  - **谁大听谁的！**

- 方程：

  
  $$
  dp[i][j] = \max(dp[i-1][j], \quad dp[i][j-1])
  $$
  

  (注：找左边和上边的最大值)

------

#### **3. 实例推导 (Example)**

假设 A = \text{"ABC"}, B = \text{"ABD"}。

我们需要求 dp[3][3] (即 A 的 'C' 和 B 的 'D' 比较)。

**填表过程模拟：**

| **A∖B**           | **∅ (0)** | **A (1)**          | **B (2)**          | **D (3)**      |
| ----------------- | --------- | ------------------ | ------------------ | -------------- |
| **\emptyset (0)** | 0         | 0                  | 0                  | 0              |
| **A (1)**         | 0         | **1** (\nwarrow+1) | 1 (\leftarrow)     | 1 (\leftarrow) |
| **B (2)**         | 0         | 1 (\uparrow)       | **2** (\nwarrow+1) | 2 (\leftarrow) |
| **C (3)**         | 0         | 1 (\uparrow)       | 2 (\uparrow)       | **?**          |

**针对 dp[3][3] 的计算 (C vs D)：**

1. **判断**：A[3] ('C') \neq B[3] ('D') \rightarrow **不相等！**

2. **查表**：

   - 上方 (dp[2][3])：对应 "AB" 和 "ABD"，长度为 2。
   - 左方 (dp[3][2])：对应 "ABC" 和 "AB"，长度为 2。

3. 决策：

   

   dp[3][3] = \max(2, 2) = 2

   

   (这也回答了你刚才的小测验，答案确实是 2)
