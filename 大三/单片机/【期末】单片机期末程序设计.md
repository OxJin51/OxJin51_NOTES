# 单片机期末程序设计

### delay.c和lcd.h的代码

delay.c代码：

```c
void delay(unsigned int z,unsigned int w)
{
	unsigned int x,y;
	for(x=0;x<z;x++)
		for(y=0;y<w;y++);
}
```

lcd.h代码：

```c
// lcd.h
#ifndef __lcd_h__
#define __lcd_h__
#define uchar unsigned char
void write_com(uchar com);
void write_dat(uchar dat);
void lcd_ins();
#endif
```

### 利用右移运算符>>实现右移走马灯

硬件连接：P2口接发光二极管。

用左移右移函数不会出现移出问题。

代码：

```c
#include<reg52.h>
/*#include<intrins.h>*/
unsigned int a,i;
void delay(unsigned int z,unsigned int w)
{
	unsigned int x,y;
	for(x=0;x<z;x++)
		for(y=0;y<w;y++);
}
void main()
{
	
	while(1)
	{
		a=0x80;
		for(i=0;i<8;i++){
		P2=a;
		delay(1000,40/2);
		a=a>>1;	}
	}
}
```

### 数码管M0~M7依次显示0~7

硬件连接：P1口接（小）数码管；P2口低三位接译码器。

代码：

```c
#include<reg52.h>
#include"delay.h"
#define uint unsigned int
uint code duanma[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07};
uint code weixuan[]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07};
uint i;
void main()
{
	while(1)
	{
		for(i=0;i<8;i++)
		{
			P2=weixuan[i];
			P1=duanma[i];
			delay(1000/100,40/10);
			P1=0x00;
		}
	}
}
```

### 蜂鸣器发出2长1短的声音，声音频率为xyHz

硬件连接：蜂鸣器接P3口第4位（P3^4）

代码：

```c
// ======= 含注释版本 =======
#include <reg52.h>
#include "delay.h"
#define uint unsigned int

sbit fmq = P1^0; // 定义蜂鸣器端口
uint i;

void main()
{
    while(1)
    {
        // 第一阶段：长鸣
        for(i=0; i<1200; i++)
        {
            fmq = ~fmq; // 产生方波
            delay(1000/x, 42/y); // 延时决定频率 (音调)
        }
        
        // 间歇
        fmq = 1; // 关闭蜂鸣器 (假设低电平触发，这里置高为灭)
        delay(1000, 42); // 静音约 0.5 秒

        // 第二阶段：长鸣 (同上)
        for(i=0; i<1200; i++)
        {
            fmq = ~fmq;
            delay(1000/x, 42/y);;
        }
        
        // 间歇
        fmq = 1;
        delay(1000, 42);

        // 第三阶段：短鸣 (次数除以3，时长变短)
        for(i=0; i<1200/3; i++)
        {
            fmq = ~fmq;
            delay(1000/x, 42/y);
        }
        
        // 间歇
        fmq = 1;
        delay(1000, 42*2);
    }
}
```



### 8个独立按键。K0~K7，按下后对应位置的数码管显示键值，松手即灭。

硬件连接：

P0口接数码管；

P2口低三位接译码器。

补：

判断题：矩阵键盘不需要消抖？答：错。独立按键和矩阵键盘都需要消抖。

消抖：一个个消抖对比集体消抖

代码：

```c
// ======= 含注释版本 =======
#include<reg52.h>
#include"delay.h"
#define uint unsigned int

// 定义按键端口
sbit k0=P1^0; sbit k1=P1^1;
sbit k2=P1^2; sbit k3=P1^3;
sbit k4=P1^4; sbit k5=P1^5;
sbit k6=P1^6; sbit k7=P1^7;

void main()
{
    P0=0x00; // 初始化灭灯
    while(1)
    {
        // 1. 粗检测：是否有任意按键按下
        if(P1!=0xff) 
            delay(1000/50,40); // 消抖延时 20ms

        // 2. 细检测：确认真的有键按下
        if(P1!=0xff)
        {
            // 3. 判断具体是哪个键，并显示对应数字
            if(k0==0) { P2=0x00; P0=0x3f; while(!k0); } // 按住K0显示0，直到松手
            if(k1==0) { P2=0x01; P0=0x06; while(!k1); } // 按住K1显示1
            if(k2==0) { P2=0x02; P0=0x5b; while(!k2); }
            if(k3==0) { P2=0x03; P0=0x4f; while(!k3); }
            if(k4==0) { P2=0x04; P0=0x66; while(!k4); }
            if(k5==0) { P2=0x05; P0=0x6d; while(!k5); }
            if(k6==0) { P2=0x06; P0=0x7d; while(!k6); }
            if(k7==0) { P2=0x07; P0=0x07; while(!k7); }
        }
        
        P0=0x00; // 松手后熄灭
    }
}
```



### 液晶显示2个字符串（串长16）

硬件连接：

LCD1602接单片机。

代码：

```c
// ======= 含注释版本 =======
#include<reg52.h>
#include"delay.h"
#include"lcd.h" // 引用LCD驱动头文件

#define uint unsigned int
#define uchar unsigned char

// 定义LCD控制引脚
sbit lcdwr=P2^5;
sbit lcdrs=P2^6;
sbit lcden=P2^7;

// 定义显示内容的字符串
uchar code s0[]="HUAINAN  SHIYUAN";
uchar code s1[]="1111111111ABCDEF";
uint i;

void main()
{
    lcd_ins(); // LCD 初始化序列

    // --- 写第一行 ---
    write_com(0x80+0x00); // 设定光标位置：第1行第1列
    for(i=0;i<16;i++)
    {
        write_dat(s0[i]); // 写入数据
        delay(1000,40);   // 稍作延时，造成打字机效果（可选）
    }

    // --- 写第二行 ---
    write_com(0x80+0x40); // 设定光标位置：第2行第1列
    for(i=0;i<16;i++)
    {
        write_dat(s1[i]);
        delay(1000,40);
    }
    
    while(1); // 程序结束，死循环保持显示
}
```



### 中断（双中断）主函数：蜂鸣器响。外部中断0：停止发声，大数码管显示0；外部中断1：停止发声，大数码管显示1



硬件连接：

蜂鸣器接P1.0口。外部中断接P3.2口，外部中断接P3.3口

代码：

```c
#include <reg52.h>
#include "delay.h"
#define uint unsigned int

uint code duanma[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07};
uint code weixuan[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
sbit fmq = P1 ^ 0;
uint i, j;

void main()
{
    IT0 = 0; EX0 = 1; EA = 1;
    IT1 = 0; EX1 = 1; PX1 = 1;
    while (1)
    {
        for (i = 0; i < 8; i++)
        {
            P2 = weixuan[i];
            P0 = duanma[i];
            delay(1000, 40);
            P0 = 0x00;
        }
    }
}

void ex0_int() interrupt 0
{
    EX0 = 0;
    fmq = ~fmq;
    delay(1000 / 1000, 40);
    EX0 = 1;
}

void ex1_int() interrupt 2
{
    EX1 = 0;
    for (j = 0; j < 600; j++)
    {
        fmq = ~fmq;
        delay(1000 / 500, 42 / 3);
    }
    fmq = 0;
    delay(1000, 40);
    EX1 = 1;
}
```



### 两个定时器实现分秒，格式MM-SS

硬件连接：

代码：

```c
// ======= 含注释版本 =======
#include<reg52.h>
#include"delay.h"
#define uint unsigned int

uint code duanma[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};
uint sum00,sum01,sum1,sum2;

void main()
{
    // TMOD 配置：T1(高4位)模式1，T0(低4位)模式1 => 0001 0001
    TMOD=0x11;
    
    // T0 初始化：50ms
    TH0=(65536-50000)/256;
    TL0=(65536-50000)%256;
    EA=1; ET0=1; TR0=1; // 开总中断，开T0中断，启动T0
    
    // T1 初始化：50ms
    TH1=(65536-50000)/256;
    TL1=(65536-50000)%256;
    ET1=1; TR1=1;       // 开T1中断，启动T1
    
    while(1)
    {
        // --- 动态扫描显示部分 ---
        // 显示分钟十位
        P2=0x02; P0=duanma[sum2/10]; delay(1000/1000,40); P0=0x00;
        // 显示分钟个位
        P2=0x03; P0=duanma[sum2%10]; delay(1000/1000,40); P0=0x00;
        
        // 显示中间的横杠 "-" (0x40)
        P2=0x04; P0=0x40;            delay(1000/1000,40); P0=0x00;

        // 显示秒钟十位
        P2=0x05; P0=duanma[sum1/10]; delay(1000/1000,40); P0=0x00;
        // 显示秒钟个位
        P2=0x06; P0=duanma[sum1%10]; delay(1000/1000,40); P0=0x00;
        
        // 简单的溢出保护（通常这部分逻辑也可以放在中断里）
        if(sum2==60) sum2=0;
        if(sum1==60) sum1=0;
    }
}

// T0 中断服务：控制秒 (sum1)
void et0_int() interrupt 1
{
    // 手动重装初值
    TH0=(65536-50000)/256;
    TL0=(65536-50000)%256;
    sum00++; 

    if(sum00==20) // 50ms * 20 = 1000ms = 1秒
    {
        sum1++;
        sum00=0;
    }
}

// T1 中断服务：独立控制分 (sum2)
void et1_int() interrupt 3
{
    TH1=(65536-50000)/256;
    TL1=(65536-50000)%256;
    sum01++;
    
    if(sum01==1200) // 50ms * 1200 = 60000ms = 1分钟
    {
        sum2++;
        sum01=0;
    }
}
```

