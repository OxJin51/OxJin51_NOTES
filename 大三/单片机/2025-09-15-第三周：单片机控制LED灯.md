# 51单片机LED控制程序应用汇总

## 前提与约定 (Prerequisites & Conventions)

### 1. 硬件连接与编号
- **端口**: 所有示例根据题目要求，分别使用`P0`口或`P2`口。
- **LED编号**: 8个LED灯从右至左编号为 **0号灯** 至 **7号灯**。
- **对应关系**: 二进制数的最低位(Bit 0)对应0号灯，最高位(Bit 7)对应7号灯。
- **点亮方式**: 所有代码示例均采用 **高电平(1)点亮LED** 的方式（对应共阴极电路或带驱动芯片的电路）。如果您的硬件是共阳极（低电平点亮），只需将 `P_x = value;` 修改为 `P_x = ~value;` 即可。

### 2. 自定义延时函数
```c
/*
 * 自定义双参数延时函数
 * 通过改变参数x和y的值来控制延时长度。
 */
void delay(unsigned int x, unsigned int y) 
{
    unsigned int i, j;
    for (i = 0; i < x; i++)
    {
        for (j = 0; j < y; j++);
    }
}
```

**计时规则**: 固定`x=1000`，通过改变`y`来控制时间：

- `delay(1000, 80);` ≈ 1 秒
- `delay(1000, 40);` ≈ 0.5 秒
- `delay(1000, 20);` ≈ 0.25 秒
- `delay(1000, 10);` ≈ 0.125 秒



### 3. 头文件

- 基础程序需要 `#include <reg52.h>`。
- 使用循环移位函数 `_crol_` 和 `_cror_` 的程序需要额外包含 `#include <intrins.h>`。

------



## 课堂应用2

### 1. 点亮偶数、奇数、全部LED

**解析**:

- **偶数灯(0,2,4,6)**: 二进制为`01010101B`，十六进制为`0x55`。
- **奇数灯(1,3,5,7)**: 二进制为`10101010B`，十六进制为`0xAA`。
- **全部灯(0-7)**: 二进制为`11111111B`，十六进制为`0xFF`。

**代码 (以点亮偶数灯为例)**:



```C
#include <reg52.h>

void main()
{
    // P0 = 0x55; // 点亮偶数灯
    // P0 = 0xAA; // 点亮奇数灯
    // P0 = 0xFF; // 点亮全部灯
    P0 = 0x55; 
    while(1);
}
```

### 2. 第5个LED以1Hz频率闪烁

**解析**:

- **5号灯**: 对应P0.5引脚，二进制为`00100000B`，十六进制为`0x20`。
- **1Hz频率**: 周期为1秒，即亮0.5秒，灭0.5秒。对应延时`delay(1000, 40);`。

**代码**:

```C
#include <reg52.h>

void delay(unsigned int x, unsigned int y); // 函数声明

void main()
{
    while(1)
    {
        P0 = 0x20; // 点亮5号灯
        delay(1000, 40); // 延时0.5秒
        P0 = 0x00; // 熄灭所有灯
        delay(1000, 40); // 延时0.5秒
    }
}

void delay(unsigned int x, unsigned int y) 
{
    unsigned int i, j;
    for (i = 0; i < x; i++)
        for (j = 0; j < y; j++);
}
```



### 3. 高4位与低4位交替闪烁

**解析**:

- **高4位(4,5,6,7号灯)**: 二进制为`11110000B`，十六进制为`0xF0`。
- **低4位(0,1,2,3号灯)**: 二进制为`00001111B`，十六进制为`0x0F`。
- **时间**: 各亮1秒，对应延时`delay(1000, 80);`。

**代码**:

```c
#include <reg52.h>

void delay(unsigned int x, unsigned int y);

void main()
{
    while(1)
    {
        P0 = 0xF0; // 点亮高4位
        delay(1000, 80); // 延时1秒
        P0 = 0x0F; // 点亮低4位
        delay(1000, 80); // 延时1秒
    }
}

void delay(unsigned int x, unsigned int y) 
{
    unsigned int i, j;
    for (i = 0; i < x; i++)
        for (j = 0; j < y; j++);
}
```

------



## 课堂应用3

### 4. 偶数位与奇数位以2Hz频率闪烁

**解析**:

- **偶数灯(0x55)** vs **奇数灯(0xAA)**。
- **2Hz频率**: 周期为0.5秒，即各亮0.25秒。对应延时`delay(1000, 20);`。

**代码**:

```c
#include <reg52.h>

void delay(unsigned int x, unsigned int y);

void main()
{
    while(1)
    {
        P0 = 0x55; // 点亮偶数灯
        delay(1000, 20); // 延时0.25秒
        P0 = 0xAA; // 点亮奇数灯
        delay(1000, 20); // 延时0.25秒
    }
}

void delay(unsigned int x, unsigned int y) 
{
    unsigned int i, j;
    for (i = 0; i < x; i++)
        for (j = 0; j < y; j++);
}
```



### 5. P2口高四位与低四位交替亮灭



**解析**: 逻辑同“课堂应用2-3”，但操作端口为`P2`。题目未指定时间，此处设为0.5秒。

**代码**:

```c
#include <reg52.h>

void delay(unsigned int x, unsigned int y);

void main()
{
    while(1)
    {
        P2 = 0xF0; // P2高四位亮
        delay(1000, 40); // 延时0.5秒
        P2 = 0x0F; // P2低四位亮
        delay(1000, 40); // 延时0.5秒
    }
}

void delay(unsigned int x, unsigned int y) 
{
    unsigned int i, j;
    for (i = 0; i < x; i++)
        for (j = 0; j < y; j++);
}
```



### 6. P2口偶数位与奇数位交替点亮，各0.25秒

**解析**: 逻辑同“课堂应用3-4”，但操作端口为`P2`，时间已指定。

**代码**:

```C
#include <reg52.h>

void delay(unsigned int x, unsigned int y);

void main()
{
    while(1)
    {
        P2 = 0x55; // P2偶数位亮
        delay(1000, 20); // 延时0.25秒
        P2 = 0xAA; // P2奇数位亮
        delay(1000, 20); // 延时0.25秒
    }
}

void delay(unsigned int x, unsigned int y) 
{
    unsigned int i, j;
    for (i = 0; i < x; i++)
        for (j = 0; j < y; j++);
}
```



## 课堂应用4

### 1. 走马灯、流水灯、左右移界定

- **走马灯**: 通常指**只有一个**亮点在移动，其余灯熄灭。
- **流水灯**: 通常指灯**依次点亮并保持**，有“充满”效果，或泛指各种动态模式。
- **左移**: 程序中对二进制数执行左移(`<<`或`_crol_`)，物理上亮点**从右向左**移动（0->7号灯）。
- **右移**: 程序中对二进制数执行右移(`>>`或`_cror_`)，物理上亮点**从左向右**移动（7->0号灯）。

### 2 & 3. 实现左右移走马灯（三种方法）

#### 方法一：位移运算符 (`<<`, `>>`)

**左移**

```C
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char a = 0x01; // 从0号灯开始
    while(1){
        P2 = a;
        delay(1000, 20);
        a <<= 1;
        if (a == 0) a = 0x01; // 移出后重置
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```

**右移**

```C
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char a = 0x80; // 从7号灯开始
    while(1){
        P2 = a;
        delay(1000, 20);
        a >>= 1;
        if (a == 0) a = 0x80; // 移出后重置
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```



#### 方法二：循环移位函数 (`_crol_`, `_cror_`)

**循环左移 (最推荐)**

```C
#include <reg52.h>
#include <intrins.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char a = 0x01;
    while(1){
        P2 = a;
        delay(1000, 20);
        a = _crol_(a, 1);
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```

**循环右移**

```C
#include <reg52.h>
#include <intrins.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char a = 0x01;
    while(1){
        P2 = a;
        delay(1000, 20);
        a = _cror_(a, 1);
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```



#### 方法三：数组法

**左移**

```C
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char table[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
    char i;
    while(1){
        for(i=0; i<8; i++){
            P2 = table[i];
            delay(1000, 20);
        }
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```

**右移**

```C
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char table[] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
    char i;
    while(1){
        for(i=0; i<8; i++){
            P2 = table[i];
            delay(1000, 20);
        }
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```

### 4. 使用数组法实现左右来回移动走马灯

**解析**: 将左右移动的模式合并到一个数组中。

**代码**:

```c
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char table[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02};
    char i;
    while(1){
        for(i=0; i<14; i++){
            P2 = table[i];
            delay(1000, 20);
        }
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```

### 5. 使用数组法实现各种流水灯

**解析**: 数组法的优势在于可以定义任意模式。

**示例1：从右向左填充式流水灯**

```c
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char table[] = {0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF};
    char i;
    while(1){
        for(i=0; i<8; i++){
            P2 = table[i];
            delay(1000, 40);
        }
        delay(1000, 80); // 全亮后保持1秒
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```

**示例2：中间向两边展开式流水灯**

```c
#include <reg52.h>
void delay(unsigned int x, unsigned int y);
void main(){
    unsigned char table[] = {0x18, 0x24, 0x42, 0x81}; // 3&4 -> 2&5 -> 1&6 -> 0&7
    char i;
    while(1){
        for(i=0; i<4; i++){
            P2 = table[i];
            delay(1000, 40);
        }
    }
}
void delay(unsigned int x, unsigned int y){ unsigned int i,j; for(i=0;i<x;i++) for(j=0;j<y;j++); }
```
