# 定时/计数器



关于内部时钟设置，过去采用11.0592

现在为了能够满足定时器/计数器的使用，要将其修改为12MHZ。便于12等分

课堂应用：

T0计时器



这几个语句是单片机定时器最核心的“初始化”步骤。如果把定时器比作一个**闹钟**，那么 `TMOD` 就是在设置闹钟的**类型**（是机械闹钟还是电子闹钟），而 `TH0/TL0` 就是在**设定时间**（让它多久响一次）。

我来为你详细拆解这两个部分。

------

### 一、 TMOD 是什么？（配置工作模式）

`TMOD` 全称是 **Timer Mode Register（定时器模式寄存器）**。它是一个 8 位的寄存器，用来控制两个定时器：**T1（定时器1）** 和 **T0（定时器0）**。

#### 1. 它的结构是怎样的？

这 8 个位被一分为二：

- **高 4 位**：控制定时器 1（T1）
- **低 4 位**：控制定时器 0（T0）

结构图如下：

| **位序** | **7**  | **6**  | **5**  | **4**  | **3**  | **2**  | **1**  | **0**  |
| -------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| **归属** | **T1** | **T1** | **T1** | **T1** | **T0** | **T0** | **T0** | **T0** |
| **功能** | GATE   | C/T    | **M1** | **M0** | GATE   | C/T    | **M1** | **M0** |

我们最关注的是 **M1** 和 **M0** 这两位，它们决定了定时器的工作模式：

| **M1** | **M0** | **模式**  | **说明**                               |
| ------ | ------ | --------- | -------------------------------------- |
| 0      | 0      | 模式0     | 13位定时器（很少用）                   |
| **0**  | **1**  | **模式1** | **16位定时器（最常用，能存最多的数）** |
| 1      | 0      | 模式2     | 8位自动重装（常用于串口通信）          |
| 1      | 1      | 模式3     | 只有T0能用                             |

#### 2. 代码 `TMOD = 0x11` 是怎么来的？

代码 `0x11` 是十六进制，转换成二进制是 `0001 0001`。

- **高 4 位（T1）是 `0001`**：
  - `GATE=0, C/T=0`：表示作为普通定时器使用。
  - `M1=0, M0=1`：表示 **T1 工作在模式 1**。
- **低 4 位（T0）是 `0001`**：
  - `GATE=0, C/T=0`：表示作为普通定时器使用。
  - `M1=0, M0=1`：表示 **T0 工作在模式 1**。

**结论**：这句话的意思是 **“把 T1 和 T0 都设置为模式 1（16位定时器模式）”**。

------

### 二、 `TH0/TL0` 计算公式是怎么回事？（设置定时时间）

这部分代码是在给定时器装入“初值”。

C

```
TH0 = (65536 - 50000) / 256;
TL0 = (65536 - 50000) % 256;
```

要理解这个公式，你需要理解单片机定时器的一个**反直觉**特性：**它是往上数的，数满了溢出才报警。**

#### 1. 为什么是 65536？

因为我们选了 模式 1，它是 16位 的定时器。

16位二进制数能表示的最大值是 $2^{16} = 65536$。

你可以把定时器想象成一个能装 65536 滴水的桶。当第 65537 滴水滴进去时，桶就溢出了（Overflow），这时候单片机就会产生中断（闹钟响了）。

#### 2. 为什么是 50000？

这是你想要的**定时时间**。

- **前提**：标准的 51 单片机（晶振 12MHz）每经过 **1微秒 (us)**，定时器里的数就会加 1。
- **目标**：你想要 **50毫秒 (ms)** 的时间。
- **换算**：50ms = 50,000us。
- **含义**：你需要定时器数 50,000 下。

#### 3. 为什么要用减法？ `65536 - 50000`

如果桶是空的（从0开始数），它要数 65536 下才会溢出。

但你只想要它数 50000 下。

所以，你不能让桶从 0 开始，你得先往桶里倒一些水，让它只剩下 50000 的空间。

$$初值 = 满量程 - 目标数$$

$$初值 = 65536 - 50000 = 15536$$

这意思是：**“定时器，请你从 15536 开始数。当你数了 50000 下之后，正好达到 65536 并溢出，然后喊我。”**

#### 4. 为什么要除以 256 和 取余 256？

算出来的初值 15536 是一个 16 位的数字（二进制 0011 1100 1011 0000）。

但是，8051 是 8位单片机，它的寄存器一次只能装 8 位数据。所以这个 16 位的数必须拆成两半来存：

- **TH0 (Timer High 0)**：存高 8 位。
- **TL0 (Timer Low 0)**：存低 8 位。

在数学上，把一个大数字拆成高位和低位的方法就是：

- **高 8 位** = `数字 / 256` （相当于二进制右移8位）
- **低 8 位** = `数字 % 256` （取余数，保留低8位）

------

### 总结

1. **`TMOD = 0x11`**：
   - 告诉单片机：“T0 和 T1 我都要用，而且都要用最常用的 **16位模式**”。
2. **`65536`**：
   - 这是 16位模式下计数器的**最大容量**（终点）。
3. **`50000`**：
   - 这是你想要的**50毫秒**（因为12MHz晶振下，1次计数=1微秒）。
4. **`65536 - 50000`**：
   - 这是**起点**。为了让它正好走 50000 步到达终点，必须从这里开始走。
5. **`/ 256` 和 `% 256`**：
   - 这是**拆包**。因为单片机肚子小（8位），吞不下 16 位的初值，必须切成两半塞进去。





你理解对了**一大半**！关于“前4位负责T1，后4位负责T0”这一点是非常正确的。

但是关于“**最后一位决定工作模式**”这一点，稍微有一点偏差。事实上，是每组的**最后两位（M1 和 M0）共同决定**了工作模式。

我画一张图，带你把这 8 个开关（8个位）彻底看清楚：

### 1. 为什么不能只看最后一位？

单片机的定时器一共有 4种模式（模式0、1、2、3）。

如果只用 1个位（bit） 来控制，只能表示 0 或 1 两种状态，不够用。

所以必须用 2个位 组合起来，才能表示 4 种状态：

- `00` -> 模式 0
- `01` -> **模式 1** （我们这次用的）
- `10` -> 模式 2
- `11` -> 模式 3

### 2. 庖丁解牛：0x11 (0001 0001) 是怎么分配的？

让我们把 `TMOD = 0x11` 拆开来看，它对应二进制 `0001 0001`。

| **位置**   | **高 4 位 (负责 T1)**       | **低 4 位 (负责 T0)**       |
| ---------- | --------------------------- | --------------------------- |
| **二进制** | **0 0 0 1**                 | **0 0 0 1**                 |
| **功能位** | GATE \| C/T \| **M1 \| M0** | GATE \| C/T \| **M1 \| M0** |
| **含义**   | 开关 \| 计时 \| **模式位**  | 开关 \| 计时 \| **模式位**  |

请看每组的最后两个红字部分（**M1** 和 **M0**）：

#### **看左边（T1 的部分）：**

- **M1 = 0**
- **M0 = 1**
- 组合起来是 `01`。
- **结论**：T1 设置为 **模式 1** (16位定时器)。

#### **看右边（T0 的部分）：**

- **M1 = 0**
- **M0 = 1**
- 组合起来也是 `01`。
- **结论**：T0 也设置为 **模式 1** (16位定时器)。

------

### 3. 如果我想换模式怎么办？（举一反三）

为了让你彻底明白，我们试着改一下配置：

假设我们要让 **T1工作在模式2**（自动重装，二进制 `10`），而 **T0保持模式1**（二进制 `01`）。

- **T1 (高4位)** 应该变成：`00` **`10`** (即十六进制 `2`)
- **T0 (低4位)** 保持不变：`00` **`01`** (即十六进制 `1`)

那么 TMOD 就应该写成：`TMOD = 0x21;`

### 总结

你之前的理解中：

1. **分组对吗？** 对。高4位给T1，低4位给T0。
2. **谁决定模式？** 不是最后一位，而是**每组的最后两位 (M1, M0)** 联手决定的。
   - 因为代码里是 `0001`，恰好 M1是0，M0是1，看起来像是只有最后一位是1，但其实 M1 的那个 0 也很重要（如果 M1 是 1，模式就变了）。

现在是不是清晰多了？1