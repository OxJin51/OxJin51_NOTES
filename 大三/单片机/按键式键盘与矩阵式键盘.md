# 独立按键式键盘与矩阵式键盘

注：如何避免每次都重写`delay()`延时函数？

**答案**: 将`delay`函数封装成一个公共模块，体现模块化的编程思想。

1.  **创建公共资源文件夹**:
    * `delay.c`
    * `delay.h`
2.  **文件 delay.c 的标准写法**:

```c
/*

 * 自定义双参数延时函数
 * 通过改变参数x和y的值来控制延时长度
   */
   void delay(unsigned int x, unsigned int y) 
   {
   unsigned int i, j;
   for (i = 0; i < x; i++)
   {
       for (j = 0; j < y; j++);
   }
   }
```

3. **头文件 `delay.h` 的标准写法**:

使用条件编译指令 `#ifndef...#define...#endif` 来防止头文件被重复包含。

```c
#ifndef __delay_h__
#define __delay_h__

void delay (unsigned int z,unsigned int w)
{
    unsigned int i,j;
    for(i=0;i<z;i++)
        for(j=0;j<w;j++);
}

#endif
```

**计时规则**：以delay(1000,40)=0.5 s 为基准来控制时间：

- `delay(1000, 40*2);`≈ 1 秒
- `delay(1000, 40);`≈ 0.5 秒
- `delay(1000, 40/2);`≈ 0.25 秒
- `delay(1000, 40/4);`≈ 0.125 秒

## 按键式键盘

位定义

Sbit K0=P1^0;

Sbit K7=P1^7;

// 对K0按键消抖示例

if(K0 == 0) delay(1000/50,40); //消抖

if(K0 == 0) {P0=0x3f;while(!K0);P0=0x00;}

如何集体消抖？

if(P1!=0xff) //说明有按键按下去了



### 课堂应用1

按下K0，数码管M0显示0，松手即灭

按下K1，数码管M1显示1，松手即灭

...

按下K7，数码管M7显示7，松手即灭

硬件连接：独立按键接P1，译码器接P2.2，2.1，2.0（因为要多管显示，需要译码器）

数码管接P0

注：只要用独立按键，就要用位定义

Sbit K0=P1^0;

...

Sbit K7=P1^7;



代码：

#include <reg52.h>
#include"delay.h"

Sbit K0=P1^0;

...

Sbit K7=P1^7;

void main()
{

​    P0=0x00;

​    while(1)
​    {

​	if(P1!=0xff)  delay(1000/50,40); //说明有按键按下去了

​	if(P1!=0xff) //真按了！

​	{

​		if(K0==0)

​		{

​			P2=0x00; //选择显示的管子

​			P0=0x3f;  // 这是0的段码

​			while(!K0);

​		}

​		if(K1==0)

​		{

​			P2=0x01;

​			P0=0x06;

​			while(!K1);

​		}

​	// 省略K2~K7，同理

​	} 

​    }
}

### 课堂应用2：数码管M6，M7上显示数字，按下K0键，数字+1，按下K7键，数字-1。数字在[0,20]这个区间上循环（0减1变成20，20加1变成0）

思路：

2个数字同时显示，这里采用动态显示（问：静态显示不行吗？）

duanma[a%10] // M7

duanma[a/10] // M6

```


#include<reg52.h>
#include"delay.h"
#define uint unsigned int
uint a;
uint code duanma[] ={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71}; //段码数组
void main()
{
    while(1)
   {
      P2=0x06;
      P0=duanma[a/10];
      delay(1000/1000,40);
      P2=0x07;
      P2=duanma[a%10];
      delay(1000/1000,40);
      P0=0x00; // 消影
      if(K0==0)  // 问题：按下到松手，已经执行了很多次++或者--，导致经常跳数。解决：delay，检测松手while(!K0)
      	delay(1000/50,40);
      if(K0==0) a++; while(!K0);
   }
}
```



## 矩阵键盘

 第一行：P1=0xfe;

P1=0xee; 0键按下

类似的，1，2，3键

0xde 1

0xbe 2

0x7e 3

P1=0xfd;

第二行：P1=0xfd;

P1=0xed 4

类似的，5，6，7键

0xdd 5

0xbd 6

0x7d 7

第三行：P1=0xfb；

P1=0xeb； 对应8键

类似的，9，10，11

0xdb 9

0xbb 10

0x7b 11

第四行等于0

P1=0xf7；

P1=0xe7； 12

类似的，13，14，15

0xd7 13

0xb7 14

0x77 15

### 课堂应用：按下矩阵键盘的0~15键，数码管M0~M7依此显示

#include<reg52.h>

#include"delay.h"

#define uint unsigned int 

uint code duanma[] ={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71}; //段码数组

uint code weixuan[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; // 选管子

uint keyv,keyw;

void main()

{

​	keyv=16;

​	while(1)

​	{

​		P1=0xfe; //第一行

​		if(P1!=0xfe) delay(1000/50,40);

​		if(P1!=0xfe) 

​		{

​			switch(P1)

​			{

​				case

​			}

​		}

​	}



}





