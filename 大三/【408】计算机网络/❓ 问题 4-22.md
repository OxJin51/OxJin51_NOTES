## 问题 4-22

**有如下的4个/24地址块，试进行最大可能的聚合。**

- •212.56.132.0/24
- •212.56.133.0/24
- •212.56.134.0/24
- •212.56.135.0/24

### 相关知识点讲解

1. **无分类编址 CIDR**：CIDR（Classless Inter-Domain Routing，无分类域间路由选择）消除了传统的 A, B, C 类地址和子网划分的概念。它使用"网络前缀" (network-prefix) 来代替网络号和子网号。
2. **CIDR 记法**：CIDR 使用"斜线记法" (slash notation)，即 `a.b.c.d/n`，其中 `n`表示网络前缀的位数。
3. **路由聚合（构造超网）**：CIDR 允许将多个连续的、具有相同网络前缀的 IP 地址组成一个"CIDR 地址块"。如果一个地址块包含了多个 C 类地址，就称为"构造超网" (supernetting)，也称为"路由聚合" (route aggregation)。
4. **聚合方法**：进行路由聚合时，需要找到这几个地址块在二进制表示下的**共同前缀**。共同前缀的长度就是聚合后地址块的新的、更短的"网络前缀"长度。

### 问题解答

这4个地址块是连续的。为了找出它们的最大共同前缀，我们将变化的第三个字节（132, 133, 134, 135）转换为二进制：

- •`212.56.132.0`= `212.56.10000100.0`
- •`212.56.133.0`= `212.56.10000101.0`
- •`212.56.134.0`= `212.56.10000110.0`
- •`212.56.135.0`= `212.56.10000111.0`

观察它们的第三个字节的二进制形式，前 6 位 `100001`是相同的。这 4 个地址块的共同前缀覆盖了前两个字节（16位）以及第三个字节的前 6 位。

- •共同前缀长度 = 8 (第一字节) + 8 (第二字节) + 6 (第三字节) = 22 位。

聚合后的网络地址取这 4 个地址中最小的那个，并将共同前缀（22位）之外的位都置为 0。

- •`212.56.10000100.0`
- •聚合后的网络地址为 `212.56.132.0`
- •聚合后的网络前缀为 `/22`

**因此，最大可能的聚合是 212.56.132.0/22**

------

## 问题 4-27

以下地址中的哪一个和 86.32/12 匹配？请说明理由。

(1) 86.33.224.123

(2) 86.79.65.216

(3) 86.58.119.74

(4) 86.68.206.154

### 相关知识点讲解

1.**CIDR 地址块**：CIDR 使用 `a.b.c.d/n`的记法，表示一个地址块，其中 `n`是网络前缀的长度。

2.**地址掩码**：与网络前缀 `n`对应的是地址掩码（或子网掩码）。它是一个 32 位的二进制数，由 `n`个连续的 1 和 `(32-n)`个连续的 0 组成。

3.**匹配规则**：要判断一个 IP 地址是否与某个地址块（如 86.32/12）匹配，就是判断该 IP 地址的前 `n`(这里是 12) 位是否与该地址块的网络前缀完全相同。

4.**查找方法**：一个标准方法是将该 IP 地址与地址块的地址掩码进行"逐位与"(AND) 运算。如果运算结果等于该地址块的网络地址，则表示匹配。

### 问题解答

我们要判断哪个地址匹配 `86.32/12`。

1.**确定前缀**：前缀长度 `n = 12`位。

2.**写出前缀的二进制**：我们只需要看 `86.32`的前 12 位。 •`86`(第一字节) = `01010110` •`32`(第二字节) = `00100000` •地址 `86.32`的前 16 位是 `01010110 00100000` •`86.32/12`的网络前缀是这 16 位中的前 12 位，即 `01010110 0010`m

3.**逐个检查选项**：我们检查每个选项的前 12 位是否与 `01010110 0010`相同。

**(1) 86.33.224.123**

- `86`= `01010110`
- `33`= `00100001`
- 该地址的前 12 位是 `01010110 0010`
- 这与目标前缀 `01010110 0010`**匹配**

**(2) 86.79.65.216**

- `86`= `01010110`
- •`79`= `01001111`
- •该地址的前 12 位是 `01010110 0100`
- •这与目标前缀 `01010110 0010`**不匹配**

**(3) 86.58.119.74**

- •`86`= `01010110`
- •`58`= `00111010`
- •该地址的前 12 位是 `01010110 0011`
- •这与目标前缀 `01010110 0010`**不匹配**

**(4) 86.68.206.154**

- •`86`= `01010110`
- •`68`= `01000100`
- •该地址的前 12 位是 `01010110 0100`
- •这与目标前缀 `01010110 0010`**不匹配**

**结论**：地址 (1) `86.33.224.123`和 `86.32/12`匹配。

------

## 问题 4-33

某单位分配到一个地址块 136.23.12.64/26。现在需要进一步划分为 4 个一样大的子网。试问：

（1） 每个子网的网络前缀有多长？

（2） 每一个子网中有多少个地址？

（3） 每一个子网的地址块是什么？

（4） 每一个子网可分配给主机使用的最小地址和最大地址是什么？

### 相关知识点讲解

1. **CIDR 地址结构**：IP 地址由网络前缀和主机号两部分组成。
2. **地址块划分**：将一个大的 CIDR 地址块划分成若干个较小的地址块，是通过增加网络前缀的位数（即借用主机号的位）来实现的。
3. **计算子网**：要划分为 4 个子网，因为 4=2²，所以需要从主机号部分借用 2 位来作为子网标识符。
4. **地址数量**：如果网络前缀为 `n`，则主机号有 `(32-n)`位，该地址块包含 2^(32−n)个地址。
5. **主机地址分配**：在分配主机号时，主机号为全 0（网络地址）和全 1（广播地址）的地址一般不使用。

### 问题解答

**（1） 每个子网的网络前缀有多长？**

- •原网络前缀是 `/26`
- •需要划分为 4 个（即 2²）相等的子网，因此需要额外借用 2 位主机号
- •新的网络前缀长度 = 26 + 2 = **28 位**

**（2） 每一个子网中有多少个地址？**

- •新的网络前缀是 `/28`，因此主机号的位数是 32 - 28 = 4 位
- •每一个子网中的地址总数 = 2⁴ = **16 个**

**（3） 每一个子网的地址块是什么？**

- •原始地址块是 136.23.12.64/26
- •`64`的二进制是 `01000000`。/26 的网络前缀是 `01`
- •我们借用接下来的 2 位作为子网号： •子网 0：`01`**`00`**`0000`= 64 •子网 1：`01`**`01`**`0000`= 80 •子网 2：`01`**`10`**`0000`= 96 •子网 3：`01`**`11`**`0000`= 112

这 4 个子网的地址块分别是：

1. 1.**136.23.12.64/28**
2. 2.**136.23.12.80/28**
3. 3.**136.23.12.96/28**
4. 4.**136.23.12.112/28**

**（4） 每一个子网可分配给主机使用的最小地址和最大地址是什么？**

- •可分配的主机地址不包括主机号全 0（网络地址）和全 1（广播地址）

**子网 1 (136.23.12.64/28):**

- •地址范围: 136.23.12.64 ~ 136.23.12.79
- •网络地址: 136.23.12.64 (主机号全 0)
- •广播地址: 136.23.12.79 (主机号全 1)
- •最小主机地址: **136.23.12.65**
- •最大主机地址: **136.23.12.78**

**子网 2 (136.23.12.80/28):**

- •地址范围: 136.23.12.80 ~ 136.23.12.95
- •网络地址: 136.23.12.80
- •广播地址: 136.23.12.95
- •最小主机地址: **136.23.12.81**
- •最大主机地址: **136.23.12.94**

**子网 3 (136.23.12.96/28):**

- •地址范围: 136.23.12.96 ~ 136.23.12.111
- •网络地址: 136.23.12.96
- •广播地址: 136.23.12.111
- •最小主机地址: **136.23.12.97**
- •最大主机地址: **136.23.12.110**

**子网 4 (136.23.12.112/28):**

- •地址范围: 136.23.12.112 ~ 136.23.12.127
- •网络地址: 136.23.12.112
- •广播地址: 136.23.12.127
- •最小主机地址: **136.23.12.113**
- •最大主机地址: **136.23.12.126**

------

## 问题 4-35

**试简述 RIP, OSPF 和 BGP 路由选择协议的主要特点。**

### 相关知识点讲解

互联网的路由选择协议是分层次的，主要分为两大类：

1. **内部网关协议 IGP (Interior Gateway Protocol)**：在一个自治系统（AS）内部（域内）使用的协议。RIP 和 OSPF 属于此类。
2. **外部网关协议 EGP (Exterior Gateway Protocol)**：在不同自治系统（AS）之间（域间）使用的协议。BGP 属于此类。

### 问题解答

#### 1. RIP (Routing Information Protocol)

RIP 是一种**内部网关协议 (IGP)**，其主要特点是：

- •它是一种分布式的、基于**距离向量 (Distance Vector)** 的路由选择协议
- •它最大的优点是**实现简单，开销较小**
- •它使用"跳数"(hop count) 作为距离的度量。路由器到直连网络的距离为 1，每经过一个路由器，跳数加 1
- •它规定"距离"最大为 15，**16 表示不可达**。这导致其网络规模有限
- •它**仅和相邻的路由器**交换信息
- •路由器交换的信息是**完整的路由表**
- •它按**固定的时间间隔**（例如 30 秒）交换路由信息
- •它的主要缺点是"**坏消息传播得慢**"，收敛时间较长

#### 2. OSPF (Open Shortest Path First)

OSPF 是一种**内部网关协议 (IGP)**，是为了克服 RIP 的缺点而开发的，其主要特点是：

- •它是一种分布式的**链路状态 (Link State)** 协议
- •它使用 **Dijkstra 最短路径算法 (SPF)** 来计算路由
- •它使用**洪泛法 (flooding)** 向本自治系统中**所有**路由器发送信息
- •路由器发送的信息是"**链路状态**"，即与本路由器相邻的路由器的信息，这只是路由器所知道的部分信息
- •**仅当链路状态发生变化时**（或每隔 30 分钟），才发送更新信息
- •每个路由器根据收到的信息建立一个**链路状态数据库 (LSDB)**，即全网的拓扑结构图
- •OSPF 的**收敛速度快**
- •它支持将一个自治系统划分为多个**区域 (area)**，有一个主干区域 (0.0.0.0)
- •它支持可变长度子网划分 (VLSM) 和无分类编址 CIDR

#### 3. BGP (Border Gateway Protocol)

BGP 是一种**外部网关协议 (EGP)**，其主要特点是：

- •它用于**不同自治系统 (AS) 之间**的路由信息交换
- •它是一种**路径向量 (path vector)** 路由选择协议
- •BGP 寻找的是一条能够到达目的网络且**比较好的路由**（不能兜圈子），而**非"最佳路由"**
- •它必须考虑**路由策略** (policy)
- •BGP 发言者 (BGP speaker) 之间通过 **TCP 连接**（端口 179）建立 BGP 会话来交换路由信息
- •路由信息中包含一个 "BGP 属性"，其中最重要的是**自治系统路径 (AS-PATH)** 和**下一跳 (NEXT-HOP)**
- •AS-PATH 属性用于**避免兜圈子**（路由环路），如果路由器在收到的路由的 AS-PATH 中看到了自己的 AS 号，就会丢弃该路由

------

## 问题 4-37

**假定网络中的路由器 B 的路由表有如下的项目（这三列分别表示"目的网络""距离"和"下一跳路由器"）**

- •N1 7 A
- •N2 2 C
- •N6 8 F
- •N8 4 E
- •N9 4 F

**现在 B 收到从 C 发来的路由信息（这两列分别表示"目的网络"和距离）：**

- •N2 4
- •N3 8
- •N6 4
- •N8 3
- •N9 5

### 相关知识点讲解

RIP 协议使用距离向量算法来更新路由表。当一个路由器（如 B）收到来自相邻路由器（如 C）的 RIP 报文时，它按以下规则处理：

1. **修改收到的报文**：路由器 B 首先修改收到的报文中的所有项目：将所有"距离"字段的值加 1（因为 B 到 C 的距离是 1），并将"下一跳"字段的地址都改为 C。

2. **逐项比较和更新**： •**新路由**：如果收到的报文中的目的网络 N 在 B 的路由表中不存在，则 B 将该项目添加到自己的路由表中 

   •**相同下一跳**：如果 B 的路由表中已有网络 N，且下一跳就是 C，则 B 用收到的新项目（修改后的）替换原项•**不同下一跳（更优）**：如果 B 的路由表中已有网络 N，但下一跳不是 C（例如是 F），B 会比较距离。如果收到的项目（修改后的）中的距离 *小于*路由表中的距离，则 B 用收到的新项目更新（替换）原条目

    •**不同下一跳（更差或相等）**：如果下一跳不同，但新距离大于或等于旧距离，则什么也不做

### 问题解答

**步骤 1：路由器 B 的原始路由表**

| 目的网络 | 距离 | 下一跳 |
| -------- | ---- | ------ |
| N1       | 7    | A      |
| N2       | 2    | C      |
| N6       | 8    | F      |
| N8       | 4    | E      |
| N9       | 4    | F      |

**步骤 2：收到 C 的路由信息，并按规则 1 修改**

B 将收到的 C 的报文中的所有距离加 1，并把下一跳设为 C。

| 目的网络 | 距离 (来自C) | 修改后距离 | 下一跳 |
| -------- | ------------ | ---------- | ------ |
| N2       | 4            | 4 + 1 = 5  | C      |
| N3       | 8            | 8 + 1 = 9  | C      |
| N6       | 4            | 4 + 1 = 5  | C      |
| N8       | 3            | 3 + 1 = 4  | C      |
| N9       | 5            | 5 + 1 = 6  | C      |

**步骤 3：B 将修改后的信息与自己的路由表比较（按规则 2）**

- •**N1**：C 的报文中没有 N1。B 保留原条目：(N1, 7, A)
- •**N2**： •B 的旧路由：(N2, 2, C) •来自 C 的新路由（修改后）：(N2, 5, C) •**规则**：下一跳相同 (都是 C)。B 更新为新条目 •**结果**：(N2, 5, C)
- •**N3**： •B 的旧路由：(无) •来自 C 的新路由（修改后）：(N3, 9, C) •**规则**：路由表中没有 N3。B 添加此新条目 •**结果**：(N3, 9, C)
- •**N6**： •B 的旧路由：(N6, 8, F) •来自 C 的新路由（修改后）：(N6, 5, C) •**规则**：下一跳不同 (F vs C)。比较距离：新距离 5 < 旧距离 8。B 更新为更优的新条目 •**结果**：(N6, 5, C)
- •**N8**： •B 的旧路由：(N8, 4, E) •来自 C 的新路由（修改后）：(N8, 4, C) •**规则**：下一跳不同 (E vs C)。比较距离：新距离 4 不小于 旧距离 4。B 保留原条目 •**结果**：(N8, 4, E)
- •**N9**： •B 的旧路由：(N9, 4, F) •来自 C 的新路由（修改后）：(N9, 6, C) •**规则**：下一跳不同 (F vs C)。比较距离：新距离 6 不小于 旧距离 4。B 保留原条目 •**结果**：(N9, 4, F)

**步骤 4：路由器 B 更新后的最终路由表**

| 目的网络 | 距离 | 下一跳 |
| -------- | ---- | ------ |
| N1       | 7    | A      |
| N2       | 5    | C      |
| N3       | 9    | C      |
| N6       | 5    | C      |
| N8       | 4    | E      |
| N9       | 4    | F      |