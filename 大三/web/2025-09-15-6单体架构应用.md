---
title: Web技术发展史：从单体架构到前后端分离
date: 2025-09-16 23:00:00 +0800
categories: [Web, 架构]
tags: [后端, 前端, 架构演进, RESTful API, JSON]
---

## Web技术发展史：从单体架构到前后端分离

### 一、 混沌期：单体架构 (Monolithic Architecture) - 2005年之前

在2005年前后，我们所熟知的Web应用主要是博客、论坛以及早期的电商网站。这些应用普遍采用一种被称为**单体架构**（Monolithic Architecture）的设计模式。

在一个单体应用中，一个软件的所有功能，包括**用户界面 (UI)**、**业务逻辑 (Business Logic)** 和 **数据访问 (Data Access)**，全部被打包在一个独立的单元里。简单来说，就是前端代码和后端代码都混在一起。

**典型技术栈：**
* **LAMP**: Linux (操作系统), Apache (Web服务器), MySQL (数据库), PHP/Perl/Python (后端语言)。
* **WAMP**: 将操作系统换为 Windows。
* **Java 技术栈**: Tomcat (Web服务器), JSP/Servlet (后端技术)。

**工作流程（以PHP为例）：**
1.  **请求**: 浏览器向服务器发送一个HTTP请求，例如 `GET /products?id=1234`。
2.  **处理**: Apache Web服务器收到请求，发现它需要由PHP脚本来处理。
3.  **渲染**: PHP脚本开始执行，它会连接数据库查询商品ID为`1234`的信息，然后将这些动态数据与预先写好的HTML模板进行混合**渲染**，动态生成一个完整的HTML页面文本。
4.  **响应**: PHP将生成好的HTML文本返回给Apache，Apache再将其作为HTTP响应发送给用户的浏览器。
5.  **展示**: 浏览器接收到HTML文件后，将其渲染成用户可以看到的页面。此时，JavaScript (以jQuery为主) 扮演着“装修工”的角色，为页面添加轮播图、选项卡等动态效果，但这属于锦上添花。

#### 状态管理：Session机制

单体架构的一个核心问题是如何在无状态的HTTP协议上“记住”用户。解决方案就是**Session（会话）机制**。

**什么是Session？**
Session是一种**服务器端**的技术机制，用于在多次请求之间跟踪和维持一个用户的状态（如登录信息、购物车内容等）。

**工作原理（“临时储物柜”模型）：**
1.  **登录验证**: 用户在登录页面输入用户名和密码提交。后端的Servlet或PHP脚本从数据库验证信息。
2.  **创建Session**: 验证成功后，服务器在自己的**内存中**创建一个`HttpSession`对象，就像为该用户分配了一个专属的**临时储物柜**。
3.  **存放数据**: 服务器将用户信息（如用户ID、用户名）存入这个储物柜。
4.  **分配钥匙**: 服务器生成一个唯一的字符串作为**Session ID**（储物柜的钥匙），并通过HTTP响应将这个Session ID以**Cookie**的形式发送给用户的浏览器。
5.  **后续请求**: 此后，浏览器向该网站发送的每一个请求，都会自动附带包含这个Session ID的Cookie。
6.  **身份识别**: 服务器每次收到请求，都会查看Cookie中的Session ID，然后用这把“钥匙”在内存中找到对应的“储物柜”，从而识别出用户的身份，无需用户重复登录。

**Session的问题：**
* **服务器压力**：每个在线用户都需要一个Session对象，当用户量巨大时，会消耗大量服务器内存。
* **可伸缩性差**：如果使用多台服务器进行**负载均衡**，用户的请求可能被分配到不同的服务器。但Session对象只存在于第一台服务器上，导致其他服务器无法识别用户身份，造成状态丢失。

---

### 二、 变革期：前后端分离的兴起

#### 转折点：Ajax技术 (2004-2010)

**Ajax (Asynchronous JavaScript and XML)** 技术的出现是Web开发的转折点。它允许浏览器在不刷新整个页面的情况下，**异步**地向服务器发送请求并接收数据，然后用JavaScript动态更新部分页面内容。

这催生了两种重要的数据交换格式：**XML** 和 **JSON**。

##### 深入理解数据格式：XML 与 JSON

它们都是纯文本的数据格式，用于以结构化的方式存储和交换数据，是前后端沟通的“语言”。

**1. XML (eXtensible Markup Language - 可扩展标记语言)**
* **语法**: 使用自定义的、成对的标签 `<tag></tag>` 来描述数据，形成树状结构。
* **数据类型**: 本身不区分数据类型，所有内容默认为字符串。
* **文件扩展名**: `.xml`
* **示例**:
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <user id="123">
      <name>张三</name>
      <age>30</age>
      <isStudent>false</isStudent>
    </user>
    ```

**2. JSON (JavaScript Object Notation - JavaScript对象表示法)**
* **语法**: 使用键值对 `{"key": "value"}` 组织数据，支持对象 `{}` 和数组 `[]`。
* **数据类型**: **有明确的数据类型** (String, Number, Boolean, Array, Object, null)。
* **文件扩展名**: `.json`
* **示例**:
    ```json
    {
      "id": 123,
      "name": "张三",
      "age": 30,
      "isStudent": false
    }
    ```

**对比总结**

| 特性         | XML            | JSON                             |
| :----------- | :------------- | :------------------------------- |
| **语法**     | 基于标签       | 基于键值对                       |
| **冗余度**   | 较高，更啰嗦   | 较低，更轻量                     |
| **数据类型** | 无内置类型     | **有内置类型**                   |
| **解析难度** | 需要专用解析器 | 可被JavaScript原生解析，非常方便 |

由于JSON的轻量和易于解析的特性，它迅速取代了XML，成为Web API的事实标准。

> **知识点补充：为什么ASP.NET的配置文件是 Web.config 而不是 Web.xml？**
> `Web.config` 文件内容确实是XML格式，但不使用 `.xml` 扩展名，主要是为了：
> 1.  **安全性**：Web服务器（如IIS）默认会**禁止**用户通过URL直接访问 `.config` 文件，防止数据库连接字符串、API密钥等敏感信息泄露。而 `.xml` 文件默认可能被直接查看。
> 2.  **框架约定**：`Web.config` 是ASP.NET框架的硬性规定，框架会自动寻找并加载这个文件作为配置。
> 3.  **身份标识**：`.config` 清晰地表明了这是一个**配置文件**，而不是普通的数据文件。

#### 成熟期：SPA 与 RESTful API (2010-2014)

随着前端技术的发展，**SPA (单页面应用)** 出现，整个应用只有一个HTML页面，页面内容的切换完全由JavaScript在前端完成。这要求前后端的职责必须完全分离，并通过一个统一、规范的接口进行通信。**RESTful API** 应运而生。

##### 深入理解前后端通信标准：RESTful API

RESTful API是一种充满了 **REST (Representational State Transfer)** 风格的API设计。它不是一项技术，而是一套架构设计的理念和规范。

**REST核心三要素**

1.  **资源 (Resource)**：API操作的对象，是“名词”。每个资源都有一个唯一的URL标识。例如 `/users`, `/users/123`。
2.  **表现层 (Representation)**：资源的具体表现形式，通常是JSON。
3.  **状态转移 (State Transfer)**：通过HTTP的**动词 (HTTP Methods)** 来操作资源，使其状态发生改变。

**“名词 (URL) + 动词 (HTTP Method)”** 构成了RESTful API的核心：

| HTTP 方法       | CRUD 操作         | 行为描述 |
| :-------------- | :---------------- | :------- |
| **GET**         | **Read (读取)**   | 获取资源 |
| **POST**        | **Create (创建)** | 新建资源 |
| **PUT / PATCH** | **Update (更新)** | 更新资源 |
| **DELETE**      | **Delete (删除)** | 删除资源 |

**示例:**
* `GET /users/123` → **获取** ID为123的**用户**。
* `DELETE /users/123` → **删除** ID为123的**用户**。

**RESTful API的六大约束**

1.  **客户端-服务器架构**: 前后端分离，职责清晰。
2.  **无状态 (Stateless)**: 这是与Session机制最根本的区别。服务器不保存任何客户端的状态。每一次请求都必须包含所有必要信息（通常通过Token），这使得系统极易扩展。
3.  **可缓存 (Cacheable)**: 响应可以被客户端缓存，提升性能。
4.  **统一接口 (Uniform Interface)**: 必须使用一套统一的规范进行通信，是REST的核心。
5.  **分层系统**: 客户端不关心中间是否有代理或负载均衡器。
6.  **按需代码 (可选)**: 服务器可向客户端发送可执行代码。

##### 核心思想转变：Session vs Token (Stateless)

前后端分离架构的核心是**无状态**，这直接导致了Session机制不再适用。现代Web应用普遍采用**基于令牌（Token-based）**的认证方式，例如 **JWT (JSON Web Token)**。

* **Session机制（有状态）**：服务器需要存储用户状态，有伸缩性问题。
* **Token机制（无状态）**：服务器不存储用户状态。用户登录后，服务器生成一个加密的Token（令牌）返回给客户端。客户端在后续请求中携带此Token，服务器只需验证Token的合法性即可，无需查找任何记录。

这里也再次澄清了**Session**和**JSON**的关系：
* **Session** 是一种**服务器端**维持状态的**技术机制**。
* **JSON** 是一种**数据交换格式**。
* 它们不是替代关系。在现代Token机制中，Token内部所承载的用户信息，通常就是用**JSON**格式来组织的。

### 总结

Web技术的发展，是一个从**紧密耦合**走向**松散耦合**，从**有状态**走向**无状态**的演进过程。单体架构简单直接，适合早期小型项目。而随着业务复杂度的提升和用户量的增长，前后端分离的架构通过RESTful API这一标准化通信协议，实现了团队的并行开发、技术的灵活选型和系统的高可伸缩性，成为了现代大型Web应用开发的主流模式。
